# Cache subtitles

import datetime
import json
import logging
import os
import sys
import time
import zipfile

from optparse import make_option

from django.core.management.base import BaseCommand, CommandError
from django.core.management import call_command

from generate_subtitle_map import SRTS_JSON_FILENAME, LANGUAGE_SRT_FILENAME, headers
from utils.subtitles import subtitle_utils, generate_subtitle_counts 
import settings
from settings import LOG as logging


download_path = settings.STATIC_ROOT + "srt/"  # kalite/static/


class LanguageCodeDoesNotExist(Exception):

    def __str__(value):
        return "The language code specified does not have any available subtitles for download."


def download_srt_from_3rd_party(*args, **kwargs):
    """Download subtitles specified by command line args"""
    # json generated by download_subtitles.py (this file)
    srt_list_path = settings.SUBTITLES_DATA_ROOT + LANGUAGE_SRT_FILENAME
    if not os.path.exists(srt_list_path):
        raise CommandError("%s not found. Please run the 'generate_subtitle_map' command before calling this command." % srt_list_path)

    language_srt_map = json.loads(open(srt_list_path).read())

    lang_code = kwargs.get("lang_code", None)

    # if language specified, do those, if not do all
    if lang_code:
        try:
            vids_in_language = language_srt_map.get(lang_code)
        except:
            raise LanguageCodeDoesNotExist()
        download_if_criteria_met(vids_in_language, *args, **kwargs)

    else:
        import pdb; pdb.set_trace()
        for lang_code, videos in language_srt_map.items():
            kwargs["lang_code"] = lang_code
            download_if_criteria_met(videos, *args, **kwargs)


def download_if_criteria_met(videos, lang_code, force, response_code, date_since_attempt, *args, **kwargs):

    """Execute download of subtitle if it meets the criteria specified by the command line args"""

    date_specified = subtitle_utils.convert_date_input(date_since_attempt)

    for youtube_id, entry in videos.items():
        last_attempt = entry.get("last_attempt")
        api_response = entry.get("api_response")
        previously_downloaded = entry.get("downloaded")

        # HELP: I feel like this set of logic gates could be more efficient or
        # easier to read
        date_test_passed = False
        response_code_test = False

        if date_specified:
            if not last_attempt or datetime.datetime.strptime(last_attempt, '%Y-%m-%d') < date_specified:
                date_test_passed = True
            else:
                logging.info(
                    "Last attempt more recent than specified date. Moving on.")
        # response code must be specified, so it must exist
        if response_code == "all" or response_code == api_response:
            response_code_test = True
        else:
            logging.info(
                "API response doesn't match specified HTTP status code. Moving on.")

        # HELP: not feeling to good stylistically for having this extra block 
        download_it = False
        if date_specified and date_test_passed and response_code_test:
            download_it = True
        elif not date_specified and response_code_test:
            download_it = True

        if download_it:
            if not previously_downloaded or force:
                logging.info("Attempting to download subtitle for lang: %s and YouTube ID: %s" % (lang_code, youtube_id))
                response = download_subtitle(youtube_id, lang_code, format="srt")
                time_of_attempt = unicode(datetime.datetime.now().date())
                if response == "client-error" or response == "server-error":
                    logging.info("Updating JSON file to record %s." % response)
                    update_json(
                        youtube_id, lang_code, previously_downloaded, response, time_of_attempt)
                else:
                    dirpath = download_path + lang_code + "/subtitles/"
                    filename = youtube_id + ".srt"
                    fullpath = dirpath + filename
                    logging.info("Writing file to %s" % fullpath)

                    if not os.path.exists(dirpath):
                        os.makedirs(dirpath)

                    with open(fullpath, 'w') as fp:
                        fp.write(response.encode('UTF-8'))

                    logging.info("Updating JSON file to record xe.")
                    update_json(youtube_id, lang_code, True, "success", time_of_attempt)
            else:
                logging.info(
                    "Already downloaded. To redownload, run again with -R.")


def download_subtitle(youtube_id, lang_code, format="srt"):
    """Return subtitles for YouTube ID in language specified. Return False if they do not exist. Update local JSON accordingly."""
    assert format=="srt", "We only support srt download at the moment."

    api_info_map = json.loads(open(settings.SUBTITLES_DATA_ROOT + SRTS_JSON_FILENAME).read())
    # get amara id
    amara_code = api_info_map.get(youtube_id).get("amara_code")

    # make request
    # Please see http://amara.readthedocs.org/en/latest/api.html
    base_url = "https://amara.org/api2/partners/videos"

    r = subtitle_utils.make_request(headers, "%s/%s/languages/%s/subtitles/?format=srt" % (
        base_url, amara_code, lang_code))
    if r:
        # return the subtitle text, replacing empty subtitle lines with
        # spaces to make the FLV player happy
        try:
            response = (r.text or "").replace("\n\n\n", "\n   \n\n").replace("\r\n\r\n\r\n", "\r\n   \r\n\r\n")
        except: 
            response = r 
        return response
    return False


def update_json(youtube_id, lang_code, downloaded, api_response, time_of_attempt):
    """Update language_srt_map to reflect download status"""
    #Open JSON file
    filepath = settings.SUBTITLES_DATA_ROOT + LANGUAGE_SRT_FILENAME
    language_srt_map = json.loads(open(filepath).read())

    # create updated entry
    entry = language_srt_map[lang_code][youtube_id] 
    entry["downloaded"] = downloaded
    entry["api_response"] = api_response
    entry["last_attempt"] = time_of_attempt
    if api_response == "success":
        entry["last_success"] = time_of_attempt

    # update full-size JSON with new information
    language_srt_map[lang_code][youtube_id].update(entry)

    # write it to file
    logging.info("File updated.")
    json_file = open(filepath, "w+")
    json_file.write(json.dumps(language_srt_map))
    json_file.close()

def generate_zipped_srts(lang_code_to_update):
    # Create media directory if it doesn't yet exist
    media_root = settings.MEDIA_ROOT
    subtitle_utils.ensure_dir(media_root)
    zip_path = media_root + "subtitles/"
    subtitle_utils.ensure_dir(zip_path)
    locale_path = settings.LOCALE_PATHS[0]
    lang_dirs = os.listdir(locale_path)
    for lang_code in lang_dirs:
        if (lang_code_to_update and lang_code_to_update == lang_code) or (not lang_code_to_update):
            if "subtitles" in os.listdir(locale_path + lang_code):
                zf = zipfile.ZipFile('%s%s_subtitles.zip' % (zip_path, lang_code), 'w')
                for root, dirs, files in os.walk("%s%s/subtitles/" % (locale_path, lang_code)):
                    for f in files:
                        zf.write(os.path.join(root, f), arcname=f)
                zf.close()
                logging.info("Zipped up a new pack for language code: %s" % lang_code)

class Command(BaseCommand):
    help = "Update the mapping of subtitles available by language for each video. Location: static/data/subtitledata/video_srts.json"

    option_list = BaseCommand.option_list + (
        make_option('-l', '--language',
                    action='store',
                    dest='lang_code',
                    default=None,
                    metavar="LANG_CODE",
                    help="Specify a particular language code to download subtitles for. Can be used with -R to update previously downloaded subtitles."),
        make_option('-f', '--force', 
                    action='store_true',
                    dest='force',
                    default=False,
                    metavar="FORCE",
                    help="Force re-downloading of previously downloaded subtitles to refresh the repo. Can be used with -l. Default behavior is to not re-download subtitles we already have."),
        make_option('-d', '--date_since_attempt',
                    action='store',
                    dest='date_since_attempt',
                    default=None,
                    metavar="DATE",
                    help="Setting a date flag will update only those entries which have not been attempted since that date. Can be combined with -r. This could potentially be useful for updating old subtitles. USAGE: '-d MM/DD/YYYY'."),
        make_option('-r', '--response_code', 
                    action='store',
                    dest='response_code',
                    default=None,
                    metavar="RESP_CODE",
                    help="Which api-response code to recheck. Can be combined with -d. USAGE: '-r all', '-r client-error', or '-r server-error'. This option is required!"),
    )

    def handle(self, *args, **options):
        if not options.get("response_code"):
            raise CommandError(
                "Response code not specified (-r flag). Please read the usage instructions more carefully and try again.")

        download_srt_from_3rd_party(**options)

        logging.info("Executed successfully! Generating new subtitle counts!")
        generate_subtitle_counts.get_new_counts()
        
        logging.info("Executed successfully! Re-zipping changed language packs!")
        generate_zipped_srts(lanaguage=options.get("language"))

        logging.info("Process complete.")
        sys.exit(1)
